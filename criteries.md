# Критерии

## Базовые

### Работоспособность

**Б1. Код соответствует техническому заданию проекта**

Все обязательные пункты технического задания выполнены

**Б2. При выполнении кода не возникает необработанных ошибок**

При открытии диалогов, загрузке данных и работе с сайтом не возникает ошибок, программа не ломается и не зависает. Сообщения о сетевых ошибках, появляющиеся в консоли не считаются

**Б3. Код является кроссбраузерным и не вызывает ошибок в разных браузерах и разных операционных системах**

При проверке этого критерия необходимо удостовериться в правильной работе и отсутствии сообщений об ошибках в выполняемых скриптах в последних двух версиях браузеров Chrome, Firefox, Safari, Microsoft Edge.

### Стиль кода, читаемость, единообразие

**Б4. Код проходит проверку ESLint**

**Б5. Название переменных, параметров, свойств и методов начинается со строчной буквы и записываются в нотации camelCase**

**Б6. Для названия значений используются английские существительные**

Сокращения в словах запрещены. Сокращённые названия переменных можно использовать, только если такое название широко распространено. Допустимые сокращения:

* xhr, для объектов XMLHttpRequest, evt для объектов Event и его производных (MouseEvent, KeyboardEvent и подобные)
* i, j, k, l, t для счётчика в цикле, j для счётчика во вложенном цикле и так далее по алфавиту (если циклов два и более, то можно не переиспользовать переменную i)
* cb для единственного колбэка в параметрах функции

**Б7. Названия констант (постоянных значений) написаны прописными (заглавными) буквами**

Слова разделяются подчёркиваниями (UPPER_SNAKE_CASE), например:

```
const MAX_HEIGHT = 400;
const EARTH_RADIUS = 6370;
```

**Б9. Перечисления (Enum) названы английскими существительными и начинаются с прописной (заглавной) буквы**

Перечисления именуются в формате CamelCase (начинаются с прописной буквы). Перечисления названы существительными в единственном числе. Для значений перечислений используется CamelCase. Для объявления перечислений используется ключевое слово enum или константные объекты (as const).

**Неправильно:**

```
// Обычный объект
const view = {
  ARTIST: 'Artist',
  GENRE: 'Genre',
}

// Имя значения начинается
// со строчной буквы
enum EndGameType {
  lives = 'lives',
  quests = 'quests',
}
```

**Правильно:**

```
// С использованием `enum`
enum View {
  Artist = 'Artist',
  Genre = 'Genre',
}

// Константный объект
const EndGameType = {
  Lives: 'lives',
  Quest: 'quests',
} as const;
```

**Б10. Массивы названы существительными во множественном числе или с использованием венгерской нотации (указанием типа в названии)**

**Неправильно:**

```
const age = [12, 40, 22, 7];
const name = ['Иван', 'Петр', 'Мария', 'Алексей'];

const wizard = {
  name: 'Гендальф',
  friend: ['Саурон', 'Фродо', 'Бильбо'],
};
```

**Правильно:**

```
const ages = [12, 40, 22, 7];
const names = ['Иван', 'Петр', 'Мария', 'Алексей'];

const wizard = {
  name: 'Гендальф',
  friendsList: ['Саурон', 'Фродо', 'Бильбо'],
};
```

**Б11. Название функции или метода содержит глагол**

Название функции/метода должно быть глаголом и соответствовать действию, которое выполняет функция/метод. Например, можно использовать глагол get для функций/методов, которые что-то возвращают

Исключения:

* Функции-конструкторы;
* Функции-обработчики/колбэки (см. соотв. критерий);
* Функции-редьюсеры. Для именования функций-редьюсеров применяются существительные (см. соотв. критерий).

**Неправильно:**

```
function function1(names) {
  names.forEach((name) => {
    console.log(name);
  });
}

const wizard = {
  name: 'Гендальф',
  action() {
    console.log('Стреляю файрболлом!');
  },
};

function randomNumber() {
  return Math.random();
}
```

**Правильно:**

```
function printNames(names) {
  names.forEach((name) => {
    console.log(name);
  });
}

const wizard = {
  name: 'Гендальф',
  fire() {
    console.log('Стреляю файрболлом!');
  },
};

function getRandomNumber() {
  return Math.random();
}
```

### Архитектура

**Б12. Для работы с адресной строкой используется React Router и только он**

Изменение адресной строки, чтение из неё и другая работа с её состоянием должна проводиться только через инструменты, которые предоставляет React Router. Альтернативные инструменты для решения этой задачи использоваться не должны

**Б13. Для хранения глобального состояния используется Redux и только он**

Критерий не касается компонентов, содержащих state. Вы по-прежнему можете использовать локальный стейт и соответствующие хуки. Этот критерий ограничивает использование паттерна FLUX только библиотекой Redux и дополнениями к ней, такими как redux-thunk. Использовать альтернативные решения, такие как Mobx не нужно

### Проект и структура файлов

**Б16. В коде проекта нет файлов, модулей и частей кода, которые не используются, включая закомментированные участки кода**

Нет файлов скриптов, которые являются «мёртвым кодом», который никогда не выполняется

**Б18. Файлы с исходным кодом размещаются в директории src. Конфигурационные файлы для пакетов располагаются в корне.**

**Б21. В названии файлов не используется разный регистр, а применяется разделение слов дефисом. Исключение составляют файлы, которые были созданы автоматически во время создания проекта.**

**Неправильно:**

```
Button.tsx
RedButton.tsx
```

**Правильно**

```
button.tsx
red-button.tsx
// Файл создан автоматически
setupTests.ts
```

**Б22. Главный файл в каждой директории, называется так же, как директория, например app/app.tsx или index.ts (если используется реэкспорт).**

## Дополнительные

### Работоспособность

**Д1. Техническое задание реализовано в полном объёме**

Все обязательные и необязательные пункты технического задания выполнены

### Стиль кода, читаемость, единообразие

**Д2. Функции-обработчики событий названы через handle**

handle + название объекта + название события Например:

* handleFormSubmit
* handleInputChange

**Д3. Составные константы собираются в перечисления (Enum) или константный объект**

Множества однотипных констант собираются в перечисления или константный объект.

**Неправильно:**

```
const EARTH_GRAVITY = 9.8;
const EARTH_RADIUS = 6370;
```

**Правильно:**

```
const enum Earth {
  Gravity = 9.8,
  Radius = 6370,
}

const AnotherEarth = {
  Gravity: 9.8,
  Radius: 6370,
} as const;
```

**Д5. В коде не используются «магические значения» или «магические типы». Под каждое значение заводится переменная, названная как константа. Под тип заводится отдельный псевдоним типа.**

**Неправильно:**

```
function saveToken(token: string) {
  // для my-token следует предусмотреть константу
  localStorage.setItem('my-token', token);
};

function getItems(filterName: string) {
  switch (filterName) {
    case 'all':
      return [];
    case 'new':
      return [];
    default:
      return [];
  }
}

getItems('all');
```

**Правильно:**

```
const TOKEN_NAME = 'my-token';
type FilterName = 'all' | 'new';

function saveToken(token: string) {
  localStorage.setItem(TOKEN_NAME, token);
};

function getItems(filterName: FilterName) {
  switch (filterName) {
    case 'all':
      return [];
    case 'new':
      return [];
    default:
      return [];
  }
}

getItems('all');
```

### React

**Д8. Структура каждого TSX-файла соблюдена**

* Импорты
* Описание типа компонента (props)
* Код компонента

Блоки кода, не описанные в этой структуре, могут быть расположены произвольно.

**Д9. Колбэки для обработки событий, переданные в props, названы через on**

**Неправильно:**

```
<Button click={() => {}}}>
```

**Правильно:**

```
<Button onClick={() => {}}>
```

**Д11. Все дополнительные ресурсы компонента (например, стили) размещаются в директории с компонентом**

### Redux

**Д12. Для создания Actions используется паттерн Action Creators**

**Д13. Для работы с асинхронными actions используется библиотека redux-thunk**

**Д14. Редьюсер не должен содержать побочных эффектов. Функция-редьюсер опирается только на state, action и чистые функции**

**Д15. Для именования функции-редьюсер используются только существительные**

**Д16. Логика изменения состояния описывается в редьюсере, а не в компоненте**

**Д17. Отсутствует «универсальный редьюсер». Редьюсеры разбиваются в соответствии с предметной областью и объединяются при помощи Combine Reducer**

**Д18. Для чтения состояния из хранилища применяются селекторы. Если требуется модифицировать результат при чтении (например, отфильтровать), студент может применить мемоизацию (пакет reselect).**

**Д19. Для именования типов действия (action type) применяется паттерн: домен/действие (something/action). Например: list/addFavorite, user/login и так далее**

### Hooks

**Д20. При изменении состояния компонента в useEffect выполняется проверка на демонтирование компонента.**

Проверка позволит избежать ошибок, когда обновление состояния происходит после отмантирования компонента.

Пример:

```
const TIMEOUT = 1000;

useEffect(() => {
  let isMounted = true;

  setTimeout(() => {
    if (isMounted) {
      // Обновить состояние компонента
    }
  }, TIMEOUT);

  return () => {
    isMounted = false;
  };
}, [/* Зависимости */]);
```

**Д21. Кастомные Hooks начинаются с префикса use<HookName>. Например: useUser**

### Корректность кода и тесты

**Д22. Существуют юнит-тесты на все состояния всех редьюсеров**

**Д23. Все компоненты в проекте покрыты тестами**

**Д24. Тестовые файлы лежат рядом с файлами, для которых написан тест. Все тесты используют в названии *.test.ts**

**Д27. Во всех видах тестовых файлов используются моковые данные для инициализации компонентов**

Моковые данные должны описывать только те props, которые важны для тестирования, остальные props не должны быть сложными. Например, если есть тест, в котором в компонент нужно передавать объект, но этот объект никак не повлияет на тест, в моке можно передать пустой объект

**Д28. В компонентах отсутствует прямое обращение к DOM-элементам (например, document.querySelector). Если требуется получить доступ к DOM-элементу, применяются ссылки (ref).**

**Д29. Глобальный стейт не содержит значений, которые вычисляются на основании других полей глобального состояния.**

Если компоненту требуются данные, которые можно получить из данных состояния или глобального состояния (валидность формы, отфильтрованные по городу предложения и так далее), то такие данные вычисляются либо в самом компоненте, либо в селекторе. Для них не заводят отдельное состояние или поле в глобальном состоянии.
